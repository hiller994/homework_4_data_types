#строки (обычный текст)

a = "Hello, word!"
a = 'Hello, word!' #отличия нет, нужно, чтобы в одной строке были разные ковычки (экранирование)

# используем \' чтобы кавычка не считалась как экранированный символ

#многострочный текс
s = """Hello 
World
!
"""

print(s)

b = """Hello \n World !"""
print(b)

#сырые строки - преобразование спец символов в обычную строку, ставя \ перед спец символом
b = """Hello \\n World !"""
print(b)
#или r перед строкой
b = r"""Hello \n World !"""
print(b)

#разделение строки
email = "user@domain.com"
print(email[1]) # выводит символ под этим индексам , отсчет сналала
print(email[-2]) # 2 символа
print(email[0:5]) # 6 символом
print(email[:5]) # аналогично, 6 сиволов из строки
print(email[0:10:2]) # берем каждый 2 символ
print(email[::-1]) #указываем от самого начала до самого конца, -1 переворачивает строку

#функции по строкам
assert email.endswith("@domain.com") #проверяем, что емаи заканчивается нужный текст

#Форматирование

a = "Hello"
b = "World"
print(a+ ", " + b + "!") # это самый простой формат ложения

print("{a}, {b}!".format(a=a, b=a)) # соединение строк через формат
print(f"{a}, {b}!") # cсовременный варинт format
# + F в том, что можно настраивать текст, например:
print(f"{a}, {b.upper()}!") #верхний регистр у ворлда
print(f"{a=}, {b=}!") #выводит название переменных
print("%s, %s!" % (a,b)) #какой то старый способ

#еще одно изпользование формата. Переиспользование формата
url_template = "https://.../api/{}"
users_url = url_template.format('users')
groups_url = url_template.format('groups')

#строки в число в наоборот
a = '1234'
n = 1234

assert a == str(n) #из числа в строку
assert int(a) == n #из строки в число, НО ТОЛЬКО ЕСЛИ в строки только цифры
assert a.isdigit() #проверям, что a точно число, т.к. если = 123abc, то проверка == не пройдет
